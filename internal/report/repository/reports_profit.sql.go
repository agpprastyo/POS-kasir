// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reports_profit.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getProductProfitReports = `-- name: GetProductProfitReports :many
SELECT
    p.id AS product_id,
    p.name AS product_name,
    SUM(oi.quantity) AS total_sold,
    SUM(oi.net_subtotal) AS total_revenue,
    SUM(oi.cost_price_at_sale * oi.quantity) AS total_cogs,
    SUM(oi.net_subtotal) - SUM(oi.cost_price_at_sale * oi.quantity) AS gross_profit
FROM order_items oi
JOIN products p ON oi.product_id = p.id
JOIN orders o ON oi.order_id = o.id
WHERE o.created_at::date BETWEEN $1 AND $2
  AND o.status IN ('paid', 'served')
GROUP BY p.id, p.name
ORDER BY gross_profit DESC
`

type GetProductProfitReportsParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetProductProfitReportsRow struct {
	ProductID    uuid.UUID `json:"product_id"`
	ProductName  string    `json:"product_name"`
	TotalSold    int64     `json:"total_sold"`
	TotalRevenue int64     `json:"total_revenue"`
	TotalCogs    int64     `json:"total_cogs"`
	GrossProfit  int32     `json:"gross_profit"`
}

func (q *Queries) GetProductProfitReports(ctx context.Context, arg GetProductProfitReportsParams) ([]GetProductProfitReportsRow, error) {
	rows, err := q.db.Query(ctx, getProductProfitReports, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductProfitReportsRow{}
	for rows.Next() {
		var i GetProductProfitReportsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.TotalSold,
			&i.TotalRevenue,
			&i.TotalCogs,
			&i.GrossProfit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfitSummary = `-- name: GetProfitSummary :many
SELECT
    created_at::date AS date,
    COALESCE(SUM(net_total), 0) AS total_revenue,
    COALESCE(SUM(
        (SELECT SUM(oi.cost_price_at_sale * oi.quantity)
         FROM order_items oi
         WHERE oi.order_id = o.id)
    ), 0) AS total_cogs,
    COALESCE(SUM(net_total), 0) - COALESCE(SUM(
        (SELECT SUM(oi.cost_price_at_sale * oi.quantity)
         FROM order_items oi
         WHERE oi.order_id = o.id)
    ), 0) AS gross_profit
FROM orders o
WHERE created_at::date BETWEEN $1 AND $2
  AND status IN ('paid', 'served')
GROUP BY date
ORDER BY date
`

type GetProfitSummaryParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetProfitSummaryRow struct {
	Date         pgtype.Date `json:"date"`
	TotalRevenue interface{} `json:"total_revenue"`
	TotalCogs    interface{} `json:"total_cogs"`
	GrossProfit  int32       `json:"gross_profit"`
}

func (q *Queries) GetProfitSummary(ctx context.Context, arg GetProfitSummaryParams) ([]GetProfitSummaryRow, error) {
	rows, err := q.db.Query(ctx, getProfitSummary, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProfitSummaryRow{}
	for rows.Next() {
		var i GetProfitSummaryRow
		if err := rows.Scan(
			&i.Date,
			&i.TotalRevenue,
			&i.TotalCogs,
			&i.GrossProfit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
