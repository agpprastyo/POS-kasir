// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: order.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addProductStock = `-- name: AddProductStock :one
UPDATE products
SET stock = stock + $2
WHERE id = $1
RETURNING id, stock
`

type AddProductStockParams struct {
	ID    uuid.UUID `json:"id"`
	Stock int32     `json:"stock"`
}

type AddProductStockRow struct {
	ID    uuid.UUID `json:"id"`
	Stock int32     `json:"stock"`
}

// Menambahkan stok kembali ke sebuah produk (digunakan saat pesanan dibatalkan).
func (q *Queries) AddProductStock(ctx context.Context, arg AddProductStockParams) (AddProductStockRow, error) {
	row := q.db.QueryRow(ctx, addProductStock, arg.ID, arg.Stock)
	var i AddProductStockRow
	err := row.Scan(&i.ID, &i.Stock)
	return i, err
}

type BatchCreateOrderItemOptionsParams struct {
	OrderItemID     uuid.UUID `json:"order_item_id"`
	ProductOptionID uuid.UUID `json:"product_option_id"`
	PriceAtSale     int64     `json:"price_at_sale"`
}

const batchCreateOrderItems = `-- name: BatchCreateOrderItems :many
INSERT INTO order_items (
    order_id,
    product_id,
    quantity,
    price_at_sale,
    subtotal,
    net_subtotal,
    cost_price_at_sale
)
SELECT
    $1 AS order_id,
    unnest($2::uuid[]) AS product_id,
    unnest($3::int[]) AS quantity,
    unnest($4::numeric[]) AS price_at_sale,
    unnest($5::numeric[]) AS subtotal,
    unnest($6::numeric[]) AS net_subtotal,
    unnest($7::numeric[]) AS cost_price_at_sale
RETURNING id, order_id, product_id, quantity, price_at_sale, subtotal, discount_amount, net_subtotal, cost_price_at_sale
`

type BatchCreateOrderItemsParams struct {
	OrderID          uuid.UUID        `json:"order_id"`
	ProductIds       []uuid.UUID      `json:"product_ids"`
	Quantities       []int32          `json:"quantities"`
	PricesAtSale     []pgtype.Numeric `json:"prices_at_sale"`
	Subtotals        []pgtype.Numeric `json:"subtotals"`
	NetSubtotals     []pgtype.Numeric `json:"net_subtotals"`
	CostPricesAtSale []pgtype.Numeric `json:"cost_prices_at_sale"`
}

// Memasukkan banyak item sekaligus menggunakan array (Bulk Insert).
func (q *Queries) BatchCreateOrderItems(ctx context.Context, arg BatchCreateOrderItemsParams) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, batchCreateOrderItems,
		arg.OrderID,
		arg.ProductIds,
		arg.Quantities,
		arg.PricesAtSale,
		arg.Subtotals,
		arg.NetSubtotals,
		arg.CostPricesAtSale,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Quantity,
			&i.PriceAtSale,
			&i.Subtotal,
			&i.DiscountAmount,
			&i.NetSubtotal,
			&i.CostPriceAtSale,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const batchDecreaseProductStock = `-- name: BatchDecreaseProductStock :exec
UPDATE products AS p
SET
    stock = p.stock - v.qty,
    updated_at = NOW()
FROM (
         SELECT
             unnest($1::uuid[]) AS id,
             unnest($2::int[]) AS qty
     ) AS v
WHERE p.id = v.id
`

type BatchDecreaseProductStockParams struct {
	ProductIds []uuid.UUID `json:"product_ids"`
	Quantities []int32     `json:"quantities"`
}

// Mengurangi stok banyak produk sekaligus berdasarkan pasangan ID dan Qty.
func (q *Queries) BatchDecreaseProductStock(ctx context.Context, arg BatchDecreaseProductStockParams) error {
	_, err := q.db.Exec(ctx, batchDecreaseProductStock, arg.ProductIds, arg.Quantities)
	return err
}

const cancelOrder = `-- name: CancelOrder :one
UPDATE orders
SET
    status = 'cancelled',
    cancellation_reason_id = $2,
    cancellation_notes = $3
WHERE
    id = $1 AND status = 'open'
RETURNING id, user_id, type, status, created_at, updated_at, gross_total, discount_amount, net_total, applied_promotion_id, payment_method_id, payment_gateway_reference, cash_received, change_due, cancellation_reason_id, cancellation_notes, payment_url, payment_token
`

type CancelOrderParams struct {
	ID                   uuid.UUID `json:"id"`
	CancellationReasonID *int32    `json:"cancellation_reason_id"`
	CancellationNotes    *string   `json:"cancellation_notes"`
}

// Mengubah status pesanan menjadi 'cancelled' dan mencatat alasannya.
// Hanya bisa membatalkan pesanan yang statusnya 'open'.
func (q *Queries) CancelOrder(ctx context.Context, arg CancelOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, cancelOrder, arg.ID, arg.CancellationReasonID, arg.CancellationNotes)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GrossTotal,
		&i.DiscountAmount,
		&i.NetTotal,
		&i.AppliedPromotionID,
		&i.PaymentMethodID,
		&i.PaymentGatewayReference,
		&i.CashReceived,
		&i.ChangeDue,
		&i.CancellationReasonID,
		&i.CancellationNotes,
		&i.PaymentUrl,
		&i.PaymentToken,
	)
	return i, err
}

const countOrders = `-- name: CountOrders :one
SELECT count(*) FROM orders
WHERE
    ($1::text[] IS NULL OR status = ANY($1::text[]::order_status[]))
  AND
    ($2::uuid IS NULL OR user_id = $2)
`

type CountOrdersParams struct {
	Statuses []string    `json:"statuses"`
	UserID   pgtype.UUID `json:"user_id"`
}

// Menghitung total pesanan dengan filter.
func (q *Queries) CountOrders(ctx context.Context, arg CountOrdersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrders, arg.Statuses, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (user_id, type )
VALUES ($1, $2 )
RETURNING id, user_id, type, status, created_at, updated_at, gross_total, discount_amount, net_total, applied_promotion_id, payment_method_id, payment_gateway_reference, cash_received, change_due, cancellation_reason_id, cancellation_notes, payment_url, payment_token
`

type CreateOrderParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Type   OrderType   `json:"type"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder, arg.UserID, arg.Type)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GrossTotal,
		&i.DiscountAmount,
		&i.NetTotal,
		&i.AppliedPromotionID,
		&i.PaymentMethodID,
		&i.PaymentGatewayReference,
		&i.CashReceived,
		&i.ChangeDue,
		&i.CancellationReasonID,
		&i.CancellationNotes,
		&i.PaymentUrl,
		&i.PaymentToken,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (
    order_id,
    product_id,
    quantity,
    price_at_sale,
    subtotal,
    net_subtotal,
    cost_price_at_sale
) VALUES (
             $1, $2, $3, $4, $5, $6, $7
         ) RETURNING id, order_id, product_id, quantity, price_at_sale, subtotal, discount_amount, net_subtotal, cost_price_at_sale
`

type CreateOrderItemParams struct {
	OrderID         uuid.UUID      `json:"order_id"`
	ProductID       uuid.UUID      `json:"product_id"`
	Quantity        int32          `json:"quantity"`
	PriceAtSale     int64          `json:"price_at_sale"`
	Subtotal        int64          `json:"subtotal"`
	NetSubtotal     int64          `json:"net_subtotal"`
	CostPriceAtSale pgtype.Numeric `json:"cost_price_at_sale"`
}

// Menambahkan satu item produk ke dalam pesanan.
func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.Quantity,
		arg.PriceAtSale,
		arg.Subtotal,
		arg.NetSubtotal,
		arg.CostPriceAtSale,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.PriceAtSale,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.NetSubtotal,
		&i.CostPriceAtSale,
	)
	return i, err
}

const createOrderItemOption = `-- name: CreateOrderItemOption :one
INSERT INTO order_item_options (
    order_item_id,
    product_option_id,
    price_at_sale
) VALUES (
             $1, $2, $3
         ) RETURNING id, order_item_id, product_option_id, price_at_sale
`

type CreateOrderItemOptionParams struct {
	OrderItemID     uuid.UUID `json:"order_item_id"`
	ProductOptionID uuid.UUID `json:"product_option_id"`
	PriceAtSale     int64     `json:"price_at_sale"`
}

// Menambahkan satu varian/opsi ke dalam sebuah order item.
func (q *Queries) CreateOrderItemOption(ctx context.Context, arg CreateOrderItemOptionParams) (OrderItemOption, error) {
	row := q.db.QueryRow(ctx, createOrderItemOption, arg.OrderItemID, arg.ProductOptionID, arg.PriceAtSale)
	var i OrderItemOption
	err := row.Scan(
		&i.ID,
		&i.OrderItemID,
		&i.ProductOptionID,
		&i.PriceAtSale,
	)
	return i, err
}

const decreaseProductStock = `-- name: DecreaseProductStock :one
UPDATE products
SET stock = stock - $2
WHERE id = $1
RETURNING id, name, category_id, image_url, price, stock, created_at, updated_at, deleted_at, cost_price
`

type DecreaseProductStockParams struct {
	ID    uuid.UUID `json:"id"`
	Stock int32     `json:"stock"`
}

// Mengurangi stok produk.
func (q *Queries) DecreaseProductStock(ctx context.Context, arg DecreaseProductStockParams) (Product, error) {
	row := q.db.QueryRow(ctx, decreaseProductStock, arg.ID, arg.Stock)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CategoryID,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CostPrice,
	)
	return i, err
}

const deleteOrderItem = `-- name: DeleteOrderItem :exec
DELETE FROM order_items WHERE id = $1 AND order_id = $2
`

type DeleteOrderItemParams struct {
	ID      uuid.UUID `json:"id"`
	OrderID uuid.UUID `json:"order_id"`
}

// Menghapus satu item dari pesanan.
func (q *Queries) DeleteOrderItem(ctx context.Context, arg DeleteOrderItemParams) error {
	_, err := q.db.Exec(ctx, deleteOrderItem, arg.ID, arg.OrderID)
	return err
}

const deleteOrderItemOptionsByOrderItemID = `-- name: DeleteOrderItemOptionsByOrderItemID :exec
DELETE FROM order_item_options WHERE order_item_id = $1
`

func (q *Queries) DeleteOrderItemOptionsByOrderItemID(ctx context.Context, orderItemID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrderItemOptionsByOrderItemID, orderItemID)
	return err
}

const deleteOrderItemsByOrderID = `-- name: DeleteOrderItemsByOrderID :exec
DELETE FROM order_items WHERE order_id = $1
`

func (q *Queries) DeleteOrderItemsByOrderID(ctx context.Context, orderID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrderItemsByOrderID, orderID)
	return err
}

const getOptionsForProducts = `-- name: GetOptionsForProducts :many
SELECT id, product_id, name, additional_price, image_url, created_at, updated_at, deleted_at FROM product_options
WHERE product_id = ANY($1::uuid[])
`

// Mengambil semua varian untuk beberapa produk.
func (q *Queries) GetOptionsForProducts(ctx context.Context, dollar_1 []uuid.UUID) ([]ProductOption, error) {
	rows, err := q.db.Query(ctx, getOptionsForProducts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductOption{}
	for rows.Next() {
		var i ProductOption
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Name,
			&i.AdditionalPrice,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderByGatewayRef = `-- name: GetOrderByGatewayRef :one
SELECT id, user_id, type, status, created_at, updated_at, gross_total, discount_amount, net_total, applied_promotion_id, payment_method_id, payment_gateway_reference, cash_received, change_due, cancellation_reason_id, cancellation_notes, payment_url, payment_token FROM orders
WHERE payment_gateway_reference = $1
LIMIT 1
`

// Mengambil pesanan berdasarkan referensi dari payment gateway.
func (q *Queries) GetOrderByGatewayRef(ctx context.Context, paymentGatewayReference *string) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByGatewayRef, paymentGatewayReference)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GrossTotal,
		&i.DiscountAmount,
		&i.NetTotal,
		&i.AppliedPromotionID,
		&i.PaymentMethodID,
		&i.PaymentGatewayReference,
		&i.CashReceived,
		&i.ChangeDue,
		&i.CancellationReasonID,
		&i.CancellationNotes,
		&i.PaymentUrl,
		&i.PaymentToken,
	)
	return i, err
}

const getOrderForUpdate = `-- name: GetOrderForUpdate :one
SELECT id, user_id, type, status, created_at, updated_at, gross_total, discount_amount, net_total, applied_promotion_id, payment_method_id, payment_gateway_reference, cash_received, change_due, cancellation_reason_id, cancellation_notes, payment_url, payment_token FROM orders
WHERE id = $1
LIMIT 1
    FOR UPDATE
`

// Mengambil satu pesanan dan mengunci barisnya untuk pembaruan (mencegah race condition).
// Penting untuk digunakan di dalam transaksi sebelum mengupdate total.
func (q *Queries) GetOrderForUpdate(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderForUpdate, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GrossTotal,
		&i.DiscountAmount,
		&i.NetTotal,
		&i.AppliedPromotionID,
		&i.PaymentMethodID,
		&i.PaymentGatewayReference,
		&i.CashReceived,
		&i.ChangeDue,
		&i.CancellationReasonID,
		&i.CancellationNotes,
		&i.PaymentUrl,
		&i.PaymentToken,
	)
	return i, err
}

const getOrderItem = `-- name: GetOrderItem :one
SELECT id, order_id, product_id, quantity, price_at_sale, subtotal, discount_amount, net_subtotal, cost_price_at_sale FROM order_items WHERE id = $1 AND order_id = $2
`

type GetOrderItemParams struct {
	ID      uuid.UUID `json:"id"`
	OrderID uuid.UUID `json:"order_id"`
}

// Mengambil satu item pesanan untuk validasi sebelum update/delete.
func (q *Queries) GetOrderItem(ctx context.Context, arg GetOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, getOrderItem, arg.ID, arg.OrderID)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.PriceAtSale,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.NetSubtotal,
		&i.CostPriceAtSale,
	)
	return i, err
}

const getOrderItemsByOrderID = `-- name: GetOrderItemsByOrderID :many
SELECT id, order_id, product_id, quantity, price_at_sale, subtotal, discount_amount, net_subtotal, cost_price_at_sale FROM order_items WHERE order_id = $1
`

// Mengambil semua item dari sebuah pesanan untuk menghitung ulang total.
func (q *Queries) GetOrderItemsByOrderID(ctx context.Context, orderID uuid.UUID) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, getOrderItemsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Quantity,
			&i.PriceAtSale,
			&i.Subtotal,
			&i.DiscountAmount,
			&i.NetSubtotal,
			&i.CostPriceAtSale,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderWithDetails = `-- name: GetOrderWithDetails :one
SELECT
    o.id, o.user_id, o.type, o.status, o.created_at, o.updated_at, o.gross_total, o.discount_amount, o.net_total, o.applied_promotion_id, o.payment_method_id, o.payment_gateway_reference, o.cash_received, o.change_due, o.cancellation_reason_id, o.cancellation_notes, o.payment_url, o.payment_token,
    COALESCE(
            (SELECT json_agg(items)
             FROM (
                      SELECT
                          oi.id, oi.order_id, oi.product_id, oi.quantity, oi.price_at_sale, oi.subtotal, oi.discount_amount, oi.net_subtotal, oi.cost_price_at_sale,
                          (SELECT json_agg(oio.*) FROM order_item_options oio WHERE oio.order_item_id = oi.id) AS options
                      FROM order_items oi
                      WHERE oi.order_id = o.id
                  ) AS items),
            '[]'::json
    ) AS items
FROM
    orders o
WHERE
    o.id = $1
LIMIT 1
`

type GetOrderWithDetailsRow struct {
	ID                      uuid.UUID          `json:"id"`
	UserID                  pgtype.UUID        `json:"user_id"`
	Type                    OrderType          `json:"type"`
	Status                  OrderStatus        `json:"status"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
	GrossTotal              int64              `json:"gross_total"`
	DiscountAmount          int64              `json:"discount_amount"`
	NetTotal                int64              `json:"net_total"`
	AppliedPromotionID      pgtype.UUID        `json:"applied_promotion_id"`
	PaymentMethodID         *int32             `json:"payment_method_id"`
	PaymentGatewayReference *string            `json:"payment_gateway_reference"`
	CashReceived            *int64             `json:"cash_received"`
	ChangeDue               *int64             `json:"change_due"`
	CancellationReasonID    *int32             `json:"cancellation_reason_id"`
	CancellationNotes       *string            `json:"cancellation_notes"`
	PaymentUrl              *string            `json:"payment_url"`
	PaymentToken            *string            `json:"payment_token"`
	Items                   interface{}        `json:"items"`
}

// Mengambil detail lengkap pesanan, termasuk item dan opsinya dalam format JSON.
func (q *Queries) GetOrderWithDetails(ctx context.Context, id uuid.UUID) (GetOrderWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getOrderWithDetails, id)
	var i GetOrderWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GrossTotal,
		&i.DiscountAmount,
		&i.NetTotal,
		&i.AppliedPromotionID,
		&i.PaymentMethodID,
		&i.PaymentGatewayReference,
		&i.CashReceived,
		&i.ChangeDue,
		&i.CancellationReasonID,
		&i.CancellationNotes,
		&i.PaymentUrl,
		&i.PaymentToken,
		&i.Items,
	)
	return i, err
}

const getProductOptionsByIDs = `-- name: GetProductOptionsByIDs :many
SELECT id, product_id, name, additional_price, image_url, created_at, updated_at, deleted_at FROM product_options
WHERE id = ANY($1::uuid[])
`

func (q *Queries) GetProductOptionsByIDs(ctx context.Context, ids []uuid.UUID) ([]ProductOption, error) {
	rows, err := q.db.Query(ctx, getProductOptionsByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductOption{}
	for rows.Next() {
		var i ProductOption
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Name,
			&i.AdditionalPrice,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByIDs = `-- name: GetProductsByIDs :many
SELECT id, name, category_id, image_url, price, stock, created_at, updated_at, deleted_at, cost_price FROM products
WHERE id = ANY($1::uuid[])
`

// Mengambil beberapa produk berdasarkan array ID. Ini untuk menghindari N+1 query.
func (q *Queries) GetProductsByIDs(ctx context.Context, dollar_1 []uuid.UUID) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CategoryID,
			&i.ImageUrl,
			&i.Price,
			&i.Stock,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CostPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsForUpdate = `-- name: GetProductsForUpdate :many
SELECT id, name, category_id, image_url, price, stock, created_at, updated_at, deleted_at, cost_price FROM products
WHERE id = ANY($1::uuid[])
    FOR UPDATE
`

// Mengambil produk sekaligus mengunci barisnya (Row-Level Locking).
// Transaksi lain yang mencoba update produk ini harus menunggu sampai transaksi ini selesai.
func (q *Queries) GetProductsForUpdate(ctx context.Context, dollar_1 []uuid.UUID) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsForUpdate, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CategoryID,
			&i.ImageUrl,
			&i.Price,
			&i.Stock,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CostPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrders = `-- name: ListOrders :many
SELECT
    id,
    user_id,
    type,
    status,
    gross_total,
    net_total,
    created_at,
    payment_method_id
FROM orders
WHERE
    ($3::text[] IS NULL OR status = ANY($3::text[]::order_status[]))
  AND
    ($4::uuid IS NULL OR user_id = $4)
ORDER BY
    created_at DESC
LIMIT $1 OFFSET $2
`

type ListOrdersParams struct {
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	Statuses []string    `json:"statuses"`
	UserID   pgtype.UUID `json:"user_id"`
}

type ListOrdersRow struct {
	ID              uuid.UUID          `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Type            OrderType          `json:"type"`
	Status          OrderStatus        `json:"status"`
	GrossTotal      int64              `json:"gross_total"`
	NetTotal        int64              `json:"net_total"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	PaymentMethodID *int32             `json:"payment_method_id"`
}

func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]ListOrdersRow, error) {
	rows, err := q.db.Query(ctx, listOrders,
		arg.Limit,
		arg.Offset,
		arg.Statuses,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrdersRow{}
	for rows.Next() {
		var i ListOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Status,
			&i.GrossTotal,
			&i.NetTotal,
			&i.CreatedAt,
			&i.PaymentMethodID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderAppliedPromotion = `-- name: UpdateOrderAppliedPromotion :exec
UPDATE orders
SET applied_promotion_id = $2
WHERE id = $1
`

type UpdateOrderAppliedPromotionParams struct {
	ID                 uuid.UUID   `json:"id"`
	AppliedPromotionID pgtype.UUID `json:"applied_promotion_id"`
}

func (q *Queries) UpdateOrderAppliedPromotion(ctx context.Context, arg UpdateOrderAppliedPromotionParams) error {
	_, err := q.db.Exec(ctx, updateOrderAppliedPromotion, arg.ID, arg.AppliedPromotionID)
	return err
}

const updateOrderItemQuantity = `-- name: UpdateOrderItemQuantity :one
UPDATE order_items
SET
    quantity = $3,
    subtotal = $4,
    net_subtotal = $5
WHERE
    id = $1 AND order_id = $2
RETURNING id, order_id, product_id, quantity, price_at_sale, subtotal, discount_amount, net_subtotal, cost_price_at_sale
`

type UpdateOrderItemQuantityParams struct {
	ID          uuid.UUID `json:"id"`
	OrderID     uuid.UUID `json:"order_id"`
	Quantity    int32     `json:"quantity"`
	Subtotal    int64     `json:"subtotal"`
	NetSubtotal int64     `json:"net_subtotal"`
}

// Update qty dan subtotal. Penting: Tambahkan validasi stok/constraint di level aplikasi
// atau pastikan trigger handle pengurangan stok jika qty bertambah.
func (q *Queries) UpdateOrderItemQuantity(ctx context.Context, arg UpdateOrderItemQuantityParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, updateOrderItemQuantity,
		arg.ID,
		arg.OrderID,
		arg.Quantity,
		arg.Subtotal,
		arg.NetSubtotal,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.PriceAtSale,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.NetSubtotal,
		&i.CostPriceAtSale,
	)
	return i, err
}

const updateOrderManualPayment = `-- name: UpdateOrderManualPayment :one
UPDATE orders
SET
    payment_method_id = $2,
    cash_received = $3,
    change_due = $4
WHERE
    id = $1
RETURNING id, user_id, type, status, created_at, updated_at, gross_total, discount_amount, net_total, applied_promotion_id, payment_method_id, payment_gateway_reference, cash_received, change_due, cancellation_reason_id, cancellation_notes, payment_url, payment_token
`

type UpdateOrderManualPaymentParams struct {
	ID              uuid.UUID `json:"id"`
	PaymentMethodID *int32    `json:"payment_method_id"`
	CashReceived    *int64    `json:"cash_received"`
	ChangeDue       *int64    `json:"change_due"`
}

// Memperbarui pesanan untuk pembayaran manual (tunai, dll.) dan mengubah status menjadi 'paid'.
// Hanya bisa memproses pesanan yang statusnya 'open'.
func (q *Queries) UpdateOrderManualPayment(ctx context.Context, arg UpdateOrderManualPaymentParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderManualPayment,
		arg.ID,
		arg.PaymentMethodID,
		arg.CashReceived,
		arg.ChangeDue,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GrossTotal,
		&i.DiscountAmount,
		&i.NetTotal,
		&i.AppliedPromotionID,
		&i.PaymentMethodID,
		&i.PaymentGatewayReference,
		&i.CashReceived,
		&i.ChangeDue,
		&i.CancellationReasonID,
		&i.CancellationNotes,
		&i.PaymentUrl,
		&i.PaymentToken,
	)
	return i, err
}

const updateOrderPaymentInfo = `-- name: UpdateOrderPaymentInfo :exec
UPDATE orders
SET
    payment_method_id = $2,
    payment_gateway_reference = $3
WHERE
    id = $1
`

type UpdateOrderPaymentInfoParams struct {
	ID                      uuid.UUID `json:"id"`
	PaymentMethodID         *int32    `json:"payment_method_id"`
	PaymentGatewayReference *string   `json:"payment_gateway_reference"`
}

// Menyimpan referensi pembayaran dari payment gateway dan metode pembayaran.
func (q *Queries) UpdateOrderPaymentInfo(ctx context.Context, arg UpdateOrderPaymentInfoParams) error {
	_, err := q.db.Exec(ctx, updateOrderPaymentInfo, arg.ID, arg.PaymentMethodID, arg.PaymentGatewayReference)
	return err
}

const updateOrderPaymentUrl = `-- name: UpdateOrderPaymentUrl :exec
UPDATE orders
SET
    payment_url = $2,
    payment_token = $3
WHERE
    id = $1
`

type UpdateOrderPaymentUrlParams struct {
	ID           uuid.UUID `json:"id"`
	PaymentUrl   *string   `json:"payment_url"`
	PaymentToken *string   `json:"payment_token"`
}

// Menyimpan URL pembayaran (QR string atau deep link) dan token.
func (q *Queries) UpdateOrderPaymentUrl(ctx context.Context, arg UpdateOrderPaymentUrlParams) error {
	_, err := q.db.Exec(ctx, updateOrderPaymentUrl, arg.ID, arg.PaymentUrl, arg.PaymentToken)
	return err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders
SET status = $2
WHERE id = $1
RETURNING id, user_id, type, status, created_at, updated_at, gross_total, discount_amount, net_total, applied_promotion_id, payment_method_id, payment_gateway_reference, cash_received, change_due, cancellation_reason_id, cancellation_notes, payment_url, payment_token
`

type UpdateOrderStatusParams struct {
	ID     uuid.UUID   `json:"id"`
	Status OrderStatus `json:"status"`
}

// Memperbarui status operasional sebuah pesanan.
// Validasi transisi status dilakukan di level aplikasi/service.
func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderStatus, arg.ID, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GrossTotal,
		&i.DiscountAmount,
		&i.NetTotal,
		&i.AppliedPromotionID,
		&i.PaymentMethodID,
		&i.PaymentGatewayReference,
		&i.CashReceived,
		&i.ChangeDue,
		&i.CancellationReasonID,
		&i.CancellationNotes,
		&i.PaymentUrl,
		&i.PaymentToken,
	)
	return i, err
}

const updateOrderStatusByGatewayRef = `-- name: UpdateOrderStatusByGatewayRef :one
UPDATE orders
SET status = $2
WHERE payment_gateway_reference = $1 AND status <> 'paid' -- Mencegah update ganda
RETURNING id, user_id, type, status, created_at, updated_at, gross_total, discount_amount, net_total, applied_promotion_id, payment_method_id, payment_gateway_reference, cash_received, change_due, cancellation_reason_id, cancellation_notes, payment_url, payment_token
`

type UpdateOrderStatusByGatewayRefParams struct {
	PaymentGatewayReference *string     `json:"payment_gateway_reference"`
	Status                  OrderStatus `json:"status"`
}

// Memperbarui status pesanan berdasarkan referensi dari payment gateway (digunakan oleh webhook).
func (q *Queries) UpdateOrderStatusByGatewayRef(ctx context.Context, arg UpdateOrderStatusByGatewayRefParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderStatusByGatewayRef, arg.PaymentGatewayReference, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GrossTotal,
		&i.DiscountAmount,
		&i.NetTotal,
		&i.AppliedPromotionID,
		&i.PaymentMethodID,
		&i.PaymentGatewayReference,
		&i.CashReceived,
		&i.ChangeDue,
		&i.CancellationReasonID,
		&i.CancellationNotes,
		&i.PaymentUrl,
		&i.PaymentToken,
	)
	return i, err
}

const updateOrderTotals = `-- name: UpdateOrderTotals :one
UPDATE orders
SET
    gross_total = $2,
    discount_amount = $3,
    net_total = $4
WHERE
    id = $1
RETURNING id, user_id, type, status, created_at, updated_at, gross_total, discount_amount, net_total, applied_promotion_id, payment_method_id, payment_gateway_reference, cash_received, change_due, cancellation_reason_id, cancellation_notes, payment_url, payment_token
`

type UpdateOrderTotalsParams struct {
	ID             uuid.UUID `json:"id"`
	GrossTotal     int64     `json:"gross_total"`
	DiscountAmount int64     `json:"discount_amount"`
	NetTotal       int64     `json:"net_total"`
}

// Memperbarui total harga, diskon, dan total bersih dari sebuah pesanan.
func (q *Queries) UpdateOrderTotals(ctx context.Context, arg UpdateOrderTotalsParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderTotals,
		arg.ID,
		arg.GrossTotal,
		arg.DiscountAmount,
		arg.NetTotal,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GrossTotal,
		&i.DiscountAmount,
		&i.NetTotal,
		&i.AppliedPromotionID,
		&i.PaymentMethodID,
		&i.PaymentGatewayReference,
		&i.CashReceived,
		&i.ChangeDue,
		&i.CancellationReasonID,
		&i.CancellationNotes,
		&i.PaymentUrl,
		&i.PaymentToken,
	)
	return i, err
}
