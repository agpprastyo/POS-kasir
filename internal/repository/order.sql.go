// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: order.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addProductStock = `-- name: AddProductStock :one
UPDATE products
SET stock = stock + $2
WHERE id = $1
RETURNING id, stock
`

type AddProductStockParams struct {
	ID    uuid.UUID `json:"id"`
	Stock int32     `json:"stock"`
}

type AddProductStockRow struct {
	ID    uuid.UUID `json:"id"`
	Stock int32     `json:"stock"`
}

// Menambahkan stok kembali ke sebuah produk (digunakan saat pesanan dibatalkan).
func (q *Queries) AddProductStock(ctx context.Context, arg AddProductStockParams) (AddProductStockRow, error) {
	row := q.db.QueryRow(ctx, addProductStock, arg.ID, arg.Stock)
	var i AddProductStockRow
	err := row.Scan(&i.ID, &i.Stock)
	return i, err
}

const cancelOrder = `-- name: CancelOrder :one
UPDATE orders
SET
    status = 'cancelled',
    cancellation_reason_id = $2,
    cancellation_notes = $3
WHERE
    id = $1 AND status = 'open'
RETURNING id, user_id, type, status, created_at, updated_at, gross_total, discount_amount, net_total, applied_promotion_id, payment_method_id, payment_gateway_reference, cash_received, change_due, cancellation_reason_id, cancellation_notes
`

type CancelOrderParams struct {
	ID                   uuid.UUID `json:"id"`
	CancellationReasonID *int32    `json:"cancellation_reason_id"`
	CancellationNotes    *string   `json:"cancellation_notes"`
}

// Mengubah status pesanan menjadi 'cancelled' dan mencatat alasannya.
// Hanya bisa membatalkan pesanan yang statusnya 'open'.
func (q *Queries) CancelOrder(ctx context.Context, arg CancelOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, cancelOrder, arg.ID, arg.CancellationReasonID, arg.CancellationNotes)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GrossTotal,
		&i.DiscountAmount,
		&i.NetTotal,
		&i.AppliedPromotionID,
		&i.PaymentMethodID,
		&i.PaymentGatewayReference,
		&i.CashReceived,
		&i.ChangeDue,
		&i.CancellationReasonID,
		&i.CancellationNotes,
	)
	return i, err
}

const countOrders = `-- name: CountOrders :one
SELECT count(*) FROM orders
WHERE
    ($1::order_status IS NULL OR status = $1)
  AND
    ($2::uuid IS NULL OR user_id = $2)
`

type CountOrdersParams struct {
	Status NullOrderStatus `json:"status"`
	UserID pgtype.UUID     `json:"user_id"`
}

// Menghitung total pesanan dengan filter.
func (q *Queries) CountOrders(ctx context.Context, arg CountOrdersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrders, arg.Status, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (user_id, type)
VALUES ($1, $2)
RETURNING id, user_id, type, status, created_at, updated_at, gross_total, discount_amount, net_total, applied_promotion_id, payment_method_id, payment_gateway_reference, cash_received, change_due, cancellation_reason_id, cancellation_notes
`

type CreateOrderParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Type   OrderType   `json:"type"`
}

// Membuat header pesanan baru dengan status 'open'.
// Total akan dihitung dan diperbarui dalam langkah selanjutnya.
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder, arg.UserID, arg.Type)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GrossTotal,
		&i.DiscountAmount,
		&i.NetTotal,
		&i.AppliedPromotionID,
		&i.PaymentMethodID,
		&i.PaymentGatewayReference,
		&i.CashReceived,
		&i.ChangeDue,
		&i.CancellationReasonID,
		&i.CancellationNotes,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (
    order_id,
    product_id,
    quantity,
    price_at_sale,
    subtotal,
    net_subtotal
) VALUES (
             $1, $2, $3, $4, $5, $6
         ) RETURNING id, order_id, product_id, quantity, price_at_sale, subtotal, discount_amount, net_subtotal
`

type CreateOrderItemParams struct {
	OrderID     uuid.UUID      `json:"order_id"`
	ProductID   uuid.UUID      `json:"product_id"`
	Quantity    int32          `json:"quantity"`
	PriceAtSale pgtype.Numeric `json:"price_at_sale"`
	Subtotal    pgtype.Numeric `json:"subtotal"`
	NetSubtotal pgtype.Numeric `json:"net_subtotal"`
}

// Menambahkan satu item produk ke dalam pesanan.
func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.Quantity,
		arg.PriceAtSale,
		arg.Subtotal,
		arg.NetSubtotal,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.PriceAtSale,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.NetSubtotal,
	)
	return i, err
}

const createOrderItemOption = `-- name: CreateOrderItemOption :one
INSERT INTO order_item_options (
    order_item_id,
    product_option_id,
    price_at_sale
) VALUES (
             $1, $2, $3
         ) RETURNING id, order_item_id, product_option_id, price_at_sale
`

type CreateOrderItemOptionParams struct {
	OrderItemID     uuid.UUID      `json:"order_item_id"`
	ProductOptionID uuid.UUID      `json:"product_option_id"`
	PriceAtSale     pgtype.Numeric `json:"price_at_sale"`
}

// Menambahkan satu varian/opsi ke dalam sebuah order item.
func (q *Queries) CreateOrderItemOption(ctx context.Context, arg CreateOrderItemOptionParams) (OrderItemOption, error) {
	row := q.db.QueryRow(ctx, createOrderItemOption, arg.OrderItemID, arg.ProductOptionID, arg.PriceAtSale)
	var i OrderItemOption
	err := row.Scan(
		&i.ID,
		&i.OrderItemID,
		&i.ProductOptionID,
		&i.PriceAtSale,
	)
	return i, err
}

const decreaseProductStock = `-- name: DecreaseProductStock :one
UPDATE products
SET stock = stock - $2
WHERE id = $1
RETURNING id, name, category_id, image_url, price, stock, created_at, updated_at, deleted_at
`

type DecreaseProductStockParams struct {
	ID    uuid.UUID `json:"id"`
	Stock int32     `json:"stock"`
}

// Mengurangi stok produk.
func (q *Queries) DecreaseProductStock(ctx context.Context, arg DecreaseProductStockParams) (Product, error) {
	row := q.db.QueryRow(ctx, decreaseProductStock, arg.ID, arg.Stock)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CategoryID,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOptionsForProducts = `-- name: GetOptionsForProducts :many
SELECT id, product_id, name, additional_price, image_url, created_at, updated_at, deleted_at FROM product_options
WHERE product_id = ANY($1::uuid[])
`

// Mengambil semua varian untuk beberapa produk.
func (q *Queries) GetOptionsForProducts(ctx context.Context, dollar_1 []uuid.UUID) ([]ProductOption, error) {
	rows, err := q.db.Query(ctx, getOptionsForProducts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductOption{}
	for rows.Next() {
		var i ProductOption
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Name,
			&i.AdditionalPrice,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderByGatewayRef = `-- name: GetOrderByGatewayRef :one
SELECT id, user_id, type, status, created_at, updated_at, gross_total, discount_amount, net_total, applied_promotion_id, payment_method_id, payment_gateway_reference, cash_received, change_due, cancellation_reason_id, cancellation_notes FROM orders
WHERE payment_gateway_reference = $1
LIMIT 1
`

// Mengambil pesanan berdasarkan referensi dari payment gateway.
func (q *Queries) GetOrderByGatewayRef(ctx context.Context, paymentGatewayReference *string) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByGatewayRef, paymentGatewayReference)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GrossTotal,
		&i.DiscountAmount,
		&i.NetTotal,
		&i.AppliedPromotionID,
		&i.PaymentMethodID,
		&i.PaymentGatewayReference,
		&i.CashReceived,
		&i.ChangeDue,
		&i.CancellationReasonID,
		&i.CancellationNotes,
	)
	return i, err
}

const getOrderForUpdate = `-- name: GetOrderForUpdate :one
SELECT id, user_id, type, status, created_at, updated_at, gross_total, discount_amount, net_total, applied_promotion_id, payment_method_id, payment_gateway_reference, cash_received, change_due, cancellation_reason_id, cancellation_notes FROM orders
WHERE id = $1
LIMIT 1
    FOR UPDATE
`

// Mengambil satu pesanan dan mengunci barisnya untuk pembaruan (mencegah race condition).
// Penting untuk digunakan di dalam transaksi sebelum mengupdate total.
func (q *Queries) GetOrderForUpdate(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderForUpdate, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GrossTotal,
		&i.DiscountAmount,
		&i.NetTotal,
		&i.AppliedPromotionID,
		&i.PaymentMethodID,
		&i.PaymentGatewayReference,
		&i.CashReceived,
		&i.ChangeDue,
		&i.CancellationReasonID,
		&i.CancellationNotes,
	)
	return i, err
}

const getOrderWithDetails = `-- name: GetOrderWithDetails :one
SELECT
    o.id, o.user_id, o.type, o.status, o.created_at, o.updated_at, o.gross_total, o.discount_amount, o.net_total, o.applied_promotion_id, o.payment_method_id, o.payment_gateway_reference, o.cash_received, o.change_due, o.cancellation_reason_id, o.cancellation_notes,
    COALESCE(
            (SELECT json_agg(items)
             FROM (
                      SELECT
                          oi.id, oi.order_id, oi.product_id, oi.quantity, oi.price_at_sale, oi.subtotal, oi.discount_amount, oi.net_subtotal,
                          (SELECT json_agg(oio.*) FROM order_item_options oio WHERE oio.order_item_id = oi.id) AS options
                      FROM order_items oi
                      WHERE oi.order_id = o.id
                  ) AS items),
            '[]'::json
    ) AS items
FROM
    orders o
WHERE
    o.id = $1
LIMIT 1
`

type GetOrderWithDetailsRow struct {
	ID                      uuid.UUID          `json:"id"`
	UserID                  pgtype.UUID        `json:"user_id"`
	Type                    OrderType          `json:"type"`
	Status                  OrderStatus        `json:"status"`
	CreatedAt               pgtype.Timestamptz `json:"created_at"`
	UpdatedAt               pgtype.Timestamptz `json:"updated_at"`
	GrossTotal              pgtype.Numeric     `json:"gross_total"`
	DiscountAmount          pgtype.Numeric     `json:"discount_amount"`
	NetTotal                pgtype.Numeric     `json:"net_total"`
	AppliedPromotionID      pgtype.UUID        `json:"applied_promotion_id"`
	PaymentMethodID         *int32             `json:"payment_method_id"`
	PaymentGatewayReference *string            `json:"payment_gateway_reference"`
	CashReceived            pgtype.Numeric     `json:"cash_received"`
	ChangeDue               pgtype.Numeric     `json:"change_due"`
	CancellationReasonID    *int32             `json:"cancellation_reason_id"`
	CancellationNotes       *string            `json:"cancellation_notes"`
	Items                   interface{}        `json:"items"`
}

// Mengambil detail lengkap pesanan, termasuk item dan opsinya dalam format JSON.
func (q *Queries) GetOrderWithDetails(ctx context.Context, id uuid.UUID) (GetOrderWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getOrderWithDetails, id)
	var i GetOrderWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GrossTotal,
		&i.DiscountAmount,
		&i.NetTotal,
		&i.AppliedPromotionID,
		&i.PaymentMethodID,
		&i.PaymentGatewayReference,
		&i.CashReceived,
		&i.ChangeDue,
		&i.CancellationReasonID,
		&i.CancellationNotes,
		&i.Items,
	)
	return i, err
}

const getProductsByIDs = `-- name: GetProductsByIDs :many
SELECT id, name, category_id, image_url, price, stock, created_at, updated_at, deleted_at FROM products
WHERE id = ANY($1::uuid[])
`

// Mengambil beberapa produk berdasarkan array ID. Ini untuk menghindari N+1 query.
func (q *Queries) GetProductsByIDs(ctx context.Context, dollar_1 []uuid.UUID) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CategoryID,
			&i.ImageUrl,
			&i.Price,
			&i.Stock,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrders = `-- name: ListOrders :many
SELECT id, user_id, type, status, created_at, updated_at, gross_total, discount_amount, net_total, applied_promotion_id, payment_method_id, payment_gateway_reference, cash_received, change_due, cancellation_reason_id, cancellation_notes FROM orders
WHERE
    ($3::order_status IS NULL OR status = $3)
  AND
    ($4::uuid IS NULL OR user_id = $4)
ORDER BY
    created_at DESC
LIMIT $1 OFFSET $2
`

type ListOrdersParams struct {
	Limit  int32           `json:"limit"`
	Offset int32           `json:"offset"`
	Status NullOrderStatus `json:"status"`
	UserID pgtype.UUID     `json:"user_id"`
}

// Mengambil daftar pesanan dengan filter dan pagination.
func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrders,
		arg.Limit,
		arg.Offset,
		arg.Status,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GrossTotal,
			&i.DiscountAmount,
			&i.NetTotal,
			&i.AppliedPromotionID,
			&i.PaymentMethodID,
			&i.PaymentGatewayReference,
			&i.CashReceived,
			&i.ChangeDue,
			&i.CancellationReasonID,
			&i.CancellationNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderPaymentInfo = `-- name: UpdateOrderPaymentInfo :exec
UPDATE orders
SET
    payment_method_id = $2,
    payment_gateway_reference = $3
WHERE
    id = $1
`

type UpdateOrderPaymentInfoParams struct {
	ID                      uuid.UUID `json:"id"`
	PaymentMethodID         *int32    `json:"payment_method_id"`
	PaymentGatewayReference *string   `json:"payment_gateway_reference"`
}

// Menyimpan referensi pembayaran dari payment gateway dan metode pembayaran.
func (q *Queries) UpdateOrderPaymentInfo(ctx context.Context, arg UpdateOrderPaymentInfoParams) error {
	_, err := q.db.Exec(ctx, updateOrderPaymentInfo, arg.ID, arg.PaymentMethodID, arg.PaymentGatewayReference)
	return err
}

const updateOrderStatusByGatewayRef = `-- name: UpdateOrderStatusByGatewayRef :one
UPDATE orders
SET status = $2
WHERE payment_gateway_reference = $1 AND status <> 'paid' -- Mencegah update ganda
RETURNING id, user_id, type, status, created_at, updated_at, gross_total, discount_amount, net_total, applied_promotion_id, payment_method_id, payment_gateway_reference, cash_received, change_due, cancellation_reason_id, cancellation_notes
`

type UpdateOrderStatusByGatewayRefParams struct {
	PaymentGatewayReference *string     `json:"payment_gateway_reference"`
	Status                  OrderStatus `json:"status"`
}

// Memperbarui status pesanan berdasarkan referensi dari payment gateway (digunakan oleh webhook).
func (q *Queries) UpdateOrderStatusByGatewayRef(ctx context.Context, arg UpdateOrderStatusByGatewayRefParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderStatusByGatewayRef, arg.PaymentGatewayReference, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GrossTotal,
		&i.DiscountAmount,
		&i.NetTotal,
		&i.AppliedPromotionID,
		&i.PaymentMethodID,
		&i.PaymentGatewayReference,
		&i.CashReceived,
		&i.ChangeDue,
		&i.CancellationReasonID,
		&i.CancellationNotes,
	)
	return i, err
}

const updateOrderTotals = `-- name: UpdateOrderTotals :one
UPDATE orders
SET
    gross_total = $2,
    discount_amount = $3,
    net_total = $4
WHERE
    id = $1
RETURNING id, user_id, type, status, created_at, updated_at, gross_total, discount_amount, net_total, applied_promotion_id, payment_method_id, payment_gateway_reference, cash_received, change_due, cancellation_reason_id, cancellation_notes
`

type UpdateOrderTotalsParams struct {
	ID             uuid.UUID      `json:"id"`
	GrossTotal     pgtype.Numeric `json:"gross_total"`
	DiscountAmount pgtype.Numeric `json:"discount_amount"`
	NetTotal       pgtype.Numeric `json:"net_total"`
}

// Memperbarui total harga, diskon, dan total bersih dari sebuah pesanan.
func (q *Queries) UpdateOrderTotals(ctx context.Context, arg UpdateOrderTotalsParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderTotals,
		arg.ID,
		arg.GrossTotal,
		arg.DiscountAmount,
		arg.NetTotal,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GrossTotal,
		&i.DiscountAmount,
		&i.NetTotal,
		&i.AppliedPromotionID,
		&i.PaymentMethodID,
		&i.PaymentGatewayReference,
		&i.CashReceived,
		&i.ChangeDue,
		&i.CancellationReasonID,
		&i.CancellationNotes,
	)
	return i, err
}
