// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: products.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countProducts = `-- name: CountProducts :one
SELECT count(*) FROM products
WHERE
    ($1::int IS NULL OR category_id = $1)
  AND
    ($2::text IS NULL OR name ILIKE '%' || $2 || '%')
`

type CountProductsParams struct {
	CategoryID *int32  `json:"category_id"`
	SearchText *string `json:"search_text"`
}

// Counts total products for pagination, respecting filters.
func (q *Queries) CountProducts(ctx context.Context, arg CountProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts, arg.CategoryID, arg.SearchText)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one

INSERT INTO products (
    name,
    category_id,
    image_url,
    price,
    stock
) VALUES (
             $1, $2, $3, $4, $5
         ) RETURNING id, name, category_id, image_url, price, stock, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	Name       string         `json:"name"`
	CategoryID *int32         `json:"category_id"`
	ImageUrl   *string        `json:"image_url"`
	Price      pgtype.Numeric `json:"price"`
	Stock      int32          `json:"stock"`
}

// Queries for Products
// Creates a new product and returns its full details.
// Product options should be created separately in a transaction.
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Name,
		arg.CategoryID,
		arg.ImageUrl,
		arg.Price,
		arg.Stock,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CategoryID,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createProductOption = `-- name: CreateProductOption :one

INSERT INTO product_options (
    product_id,
    name,
    additional_price,
    image_url
) VALUES (
             $1, $2, $3, $4
         ) RETURNING id, product_id, name, additional_price, image_url, created_at, updated_at, deleted_at
`

type CreateProductOptionParams struct {
	ProductID       uuid.UUID      `json:"product_id"`
	Name            string         `json:"name"`
	AdditionalPrice pgtype.Numeric `json:"additional_price"`
	ImageUrl        *string        `json:"image_url"`
}

// Queries for Product Options (Variants)
// Creates a new option for a specific product.
func (q *Queries) CreateProductOption(ctx context.Context, arg CreateProductOptionParams) (ProductOption, error) {
	row := q.db.QueryRow(ctx, createProductOption,
		arg.ProductID,
		arg.Name,
		arg.AdditionalPrice,
		arg.ImageUrl,
	)
	var i ProductOption
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.AdditionalPrice,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products
WHERE id = $1
`

// Deletes a product. Its options will be deleted automatically due to 'ON DELETE CASCADE'.
func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const getProductOption = `-- name: GetProductOption :one
SELECT id, product_id, name, additional_price, image_url, created_at, updated_at, deleted_at FROM product_options
WHERE id = $1 AND product_id = $2
LIMIT 1
`

type GetProductOptionParams struct {
	ID        uuid.UUID `json:"id"`
	ProductID uuid.UUID `json:"product_id"`
}

// Mengambil satu varian produk berdasarkan ID dan ID produk induknya.
func (q *Queries) GetProductOption(ctx context.Context, arg GetProductOptionParams) (ProductOption, error) {
	row := q.db.QueryRow(ctx, getProductOption, arg.ID, arg.ProductID)
	var i ProductOption
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.AdditionalPrice,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductWithOptions = `-- name: GetProductWithOptions :one
SELECT
    p.id, p.name, p.category_id, p.image_url, p.price, p.stock, p.created_at, p.updated_at, p.deleted_at,
    COALESCE(
            (SELECT json_agg(po.*) FROM product_options po WHERE po.product_id = p.id),
            '[]'::json
    ) AS options
FROM
    products p
WHERE
    p.id = $1
    AND p.deleted_at IS NULL
LIMIT 1
`

type GetProductWithOptionsRow struct {
	ID         uuid.UUID          `json:"id"`
	Name       string             `json:"name"`
	CategoryID *int32             `json:"category_id"`
	ImageUrl   *string            `json:"image_url"`
	Price      pgtype.Numeric     `json:"price"`
	Stock      int32              `json:"stock"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	DeletedAt  pgtype.Timestamptz `json:"deleted_at"`
	Options    interface{}        `json:"options"`
}

// Retrieves a single product and aggregates its options into a JSON array.
// This is an efficient way to fetch a product and its variants in one query.
func (q *Queries) GetProductWithOptions(ctx context.Context, id uuid.UUID) (GetProductWithOptionsRow, error) {
	row := q.db.QueryRow(ctx, getProductWithOptions, id)
	var i GetProductWithOptionsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CategoryID,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Options,
	)
	return i, err
}

const listOptionsForProduct = `-- name: ListOptionsForProduct :many
SELECT id, product_id, name, additional_price, image_url, created_at, updated_at, deleted_at FROM product_options
WHERE product_id = $1
ORDER BY name ASC
`

// Retrieves all options for a single product.
func (q *Queries) ListOptionsForProduct(ctx context.Context, productID uuid.UUID) ([]ProductOption, error) {
	rows, err := q.db.Query(ctx, listOptionsForProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductOption{}
	for rows.Next() {
		var i ProductOption
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Name,
			&i.AdditionalPrice,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT
    p.id,
    p.name,
    p.price,
    p.stock,
    p.image_url,
    c.name as category_name
FROM
    products p
        LEFT JOIN
    categories c ON p.category_id = c.id
WHERE
    ($3::int IS NULL OR p.category_id = $3)
  AND
    ($4::text IS NULL OR p.name ILIKE '%' || $4 || '%')
  AND p.deleted_at IS NULL
ORDER BY
    p.name ASC
LIMIT $1 OFFSET $2
`

type ListProductsParams struct {
	Limit      int32   `json:"limit"`
	Offset     int32   `json:"offset"`
	CategoryID *int32  `json:"category_id"`
	SearchText *string `json:"search_text"`
}

type ListProductsRow struct {
	ID           uuid.UUID      `json:"id"`
	Name         string         `json:"name"`
	Price        pgtype.Numeric `json:"price"`
	Stock        int32          `json:"stock"`
	ImageUrl     *string        `json:"image_url"`
	CategoryName *string        `json:"category_name"`
}

// Lists products with filtering and pagination.
// Does not include variants for performance reasons on a list view.
func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]ListProductsRow, error) {
	rows, err := q.db.Query(ctx, listProducts,
		arg.Limit,
		arg.Offset,
		arg.CategoryID,
		arg.SearchText,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProductsRow{}
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Stock,
			&i.ImageUrl,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteProduct = `-- name: SoftDeleteProduct :exec
UPDATE products
SET deleted_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteProduct, id)
	return err
}

const softDeleteProductOption = `-- name: SoftDeleteProductOption :exec
update product_options
SET deleted_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

// Deletes a single product option.
func (q *Queries) SoftDeleteProductOption(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteProductOption, id)
	return err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET
    name = COALESCE($1, name),
    category_id = COALESCE($2, category_id),
    image_url = COALESCE($3, image_url),
    price = COALESCE($4, price),
    stock = COALESCE($5, stock)
WHERE
    id = $6
RETURNING id, name, category_id, image_url, price, stock, created_at, updated_at, deleted_at
`

type UpdateProductParams struct {
	Name       *string        `json:"name"`
	CategoryID *int32         `json:"category_id"`
	ImageUrl   *string        `json:"image_url"`
	Price      pgtype.Numeric `json:"price"`
	Stock      *int32         `json:"stock"`
	ID         uuid.UUID      `json:"id"`
}

// Updates a product's details. Use COALESCE for optional fields.
func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.Name,
		arg.CategoryID,
		arg.ImageUrl,
		arg.Price,
		arg.Stock,
		arg.ID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CategoryID,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateProductOption = `-- name: UpdateProductOption :one
UPDATE product_options
SET
    name = COALESCE($1, name),
    additional_price = COALESCE($2, additional_price),
    image_url = COALESCE($3, image_url)
WHERE
    id = $4
RETURNING id, product_id, name, additional_price, image_url, created_at, updated_at, deleted_at
`

type UpdateProductOptionParams struct {
	Name            *string        `json:"name"`
	AdditionalPrice pgtype.Numeric `json:"additional_price"`
	ImageUrl        *string        `json:"image_url"`
	ID              uuid.UUID      `json:"id"`
}

// Updates a specific product option.
func (q *Queries) UpdateProductOption(ctx context.Context, arg UpdateProductOptionParams) (ProductOption, error) {
	row := q.db.QueryRow(ctx, updateProductOption,
		arg.Name,
		arg.AdditionalPrice,
		arg.ImageUrl,
		arg.ID,
	)
	var i ProductOption
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.AdditionalPrice,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
