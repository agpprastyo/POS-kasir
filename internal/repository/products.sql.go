// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countDeletedProducts = `-- name: CountDeletedProducts :one
SELECT count(*) FROM products
WHERE
    ($1::int IS NULL OR category_id = $1)
  AND
    ($2::text IS NULL OR name ILIKE '%' || $2 || '%')
  AND deleted_at IS NOT NULL
`

type CountDeletedProductsParams struct {
	CategoryID *int32  `json:"category_id"`
	SearchText *string `json:"search_text"`
}

func (q *Queries) CountDeletedProducts(ctx context.Context, arg CountDeletedProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDeletedProducts, arg.CategoryID, arg.SearchText)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProducts = `-- name: CountProducts :one
SELECT count(*) FROM products
WHERE
    ($1::int IS NULL OR category_id = $1)
  AND
    ($2::text IS NULL OR name ILIKE '%' || $2 || '%')
  AND deleted_at IS NULL
`

type CountProductsParams struct {
	CategoryID *int32  `json:"category_id"`
	SearchText *string `json:"search_text"`
}

// Counts total products for pagination, respecting filters.
func (q *Queries) CountProducts(ctx context.Context, arg CountProductsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts, arg.CategoryID, arg.SearchText)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one

INSERT INTO products (
    name,
    category_id,
    image_url,
    price,
    stock
) VALUES (
             $1, $2, $3, $4, $5
         ) RETURNING id, name, category_id, image_url, price, stock, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	Name       string  `json:"name"`
	CategoryID *int32  `json:"category_id"`
	ImageUrl   *string `json:"image_url"`
	Price      int64   `json:"price"`
	Stock      int32   `json:"stock"`
}

// Queries for Products
// Creates a new product and returns its full details.
// Product options should be created separately in a transaction.
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Name,
		arg.CategoryID,
		arg.ImageUrl,
		arg.Price,
		arg.Stock,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CategoryID,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createProductOption = `-- name: CreateProductOption :one

INSERT INTO product_options (
    product_id,
    name,
    additional_price,
    image_url
) VALUES (
             $1, $2, $3, $4
         ) RETURNING id, product_id, name, additional_price, image_url, created_at, updated_at, deleted_at
`

type CreateProductOptionParams struct {
	ProductID       uuid.UUID `json:"product_id"`
	Name            string    `json:"name"`
	AdditionalPrice int64     `json:"additional_price"`
	ImageUrl        *string   `json:"image_url"`
}

// Queries for Product Options (Variants)
// Creates a new option for a specific product.
func (q *Queries) CreateProductOption(ctx context.Context, arg CreateProductOptionParams) (ProductOption, error) {
	row := q.db.QueryRow(ctx, createProductOption,
		arg.ProductID,
		arg.Name,
		arg.AdditionalPrice,
		arg.ImageUrl,
	)
	var i ProductOption
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.AdditionalPrice,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products
WHERE id = $1
`

// Deletes a product. Its options will be deleted automatically due to 'ON DELETE CASCADE'.
func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const getDeletedProduct = `-- name: GetDeletedProduct :one
SELECT
    p.id, p.name, p.category_id, p.image_url, p.price, p.stock, p.created_at, p.updated_at, p.deleted_at,
    COALESCE(
            (SELECT json_agg(po.*)
             FROM product_options po
             WHERE po.product_id = p.id), -- Include all options (even deleted ones optionally, but usually strictly matching parent state or just all)
            '[]'::json
    ) AS options
FROM
    products p
WHERE
    p.id = $1
  AND p.deleted_at IS NOT NULL
LIMIT 1
`

type GetDeletedProductRow struct {
	ID         uuid.UUID          `json:"id"`
	Name       string             `json:"name"`
	CategoryID *int32             `json:"category_id"`
	ImageUrl   *string            `json:"image_url"`
	Price      int64              `json:"price"`
	Stock      int32              `json:"stock"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	DeletedAt  pgtype.Timestamptz `json:"deleted_at"`
	Options    interface{}        `json:"options"`
}

func (q *Queries) GetDeletedProduct(ctx context.Context, id uuid.UUID) (GetDeletedProductRow, error) {
	row := q.db.QueryRow(ctx, getDeletedProduct, id)
	var i GetDeletedProductRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CategoryID,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Options,
	)
	return i, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT
    p.id, p.name, p.category_id, p.image_url, p.price, p.stock, p.created_at, p.updated_at, p.deleted_at,
    COALESCE(
            (SELECT json_agg(po.*)
             FROM product_options po
             WHERE po.product_id = p.id AND po.deleted_at IS NULL), -- <-- TAMBAHAN DI SINI
            '[]'::json
    ) AS options
FROM
    products p
WHERE
    p.id = $1
  AND p.deleted_at IS NULL
LIMIT 1
`

type GetProductByIDRow struct {
	ID         uuid.UUID          `json:"id"`
	Name       string             `json:"name"`
	CategoryID *int32             `json:"category_id"`
	ImageUrl   *string            `json:"image_url"`
	Price      int64              `json:"price"`
	Stock      int32              `json:"stock"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	DeletedAt  pgtype.Timestamptz `json:"deleted_at"`
	Options    interface{}        `json:"options"`
}

// Retrieves a product by its ID, including its options.
func (q *Queries) GetProductByID(ctx context.Context, id uuid.UUID) (GetProductByIDRow, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i GetProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CategoryID,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Options,
	)
	return i, err
}

const getProductOption = `-- name: GetProductOption :one
SELECT id, product_id, name, additional_price, image_url, created_at, updated_at, deleted_at FROM product_options
WHERE id = $1 AND product_id = $2
LIMIT 1
`

type GetProductOptionParams struct {
	ID        uuid.UUID `json:"id"`
	ProductID uuid.UUID `json:"product_id"`
}

// Mengambil satu varian produk berdasarkan ID dan ID produk induknya.
func (q *Queries) GetProductOption(ctx context.Context, arg GetProductOptionParams) (ProductOption, error) {
	row := q.db.QueryRow(ctx, getProductOption, arg.ID, arg.ProductID)
	var i ProductOption
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.AdditionalPrice,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductOptionByID = `-- name: GetProductOptionByID :one
SELECT
    po.id, po.product_id, po.name, po.additional_price, po.image_url, po.created_at, po.updated_at, po.deleted_at,
    p.name AS product_name,
    p.category_id AS product_category_id,
    p.image_url AS product_image_url,
    p.price AS product_price,
    p.stock AS product_stock
FROM
    product_options po
        JOIN
    products p ON po.product_id = p.id
WHERE
    po.id = $1
  AND po.deleted_at IS NULL -- <-- TAMBAHAN DI SINI
  AND p.deleted_at IS NULL -- <-- TAMBAHAN DI SINI
ORDER BY
    po.name ASC
LIMIT 1
`

type GetProductOptionByIDRow struct {
	ID                uuid.UUID          `json:"id"`
	ProductID         uuid.UUID          `json:"product_id"`
	Name              string             `json:"name"`
	AdditionalPrice   int64              `json:"additional_price"`
	ImageUrl          *string            `json:"image_url"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	ProductName       string             `json:"product_name"`
	ProductCategoryID *int32             `json:"product_category_id"`
	ProductImageUrl   *string            `json:"product_image_url"`
	ProductPrice      int64              `json:"product_price"`
	ProductStock      int32              `json:"product_stock"`
}

// Retrieves a product option by its ID, including its product details.
func (q *Queries) GetProductOptionByID(ctx context.Context, id uuid.UUID) (GetProductOptionByIDRow, error) {
	row := q.db.QueryRow(ctx, getProductOptionByID, id)
	var i GetProductOptionByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.AdditionalPrice,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProductName,
		&i.ProductCategoryID,
		&i.ProductImageUrl,
		&i.ProductPrice,
		&i.ProductStock,
	)
	return i, err
}

const getProductWithOptions = `-- name: GetProductWithOptions :one
SELECT
    p.id, p.name, p.category_id, p.image_url, p.price, p.stock, p.created_at, p.updated_at, p.deleted_at,
    COALESCE(
            (SELECT json_agg(po.*)
             FROM product_options po
             WHERE po.product_id = p.id AND po.deleted_at IS NULL), -- <-- TAMBAHAN DI SINI
            '[]'::json
    ) AS options
FROM
    products p
WHERE
    p.id = $1
  AND p.deleted_at IS NULL
LIMIT 1
`

type GetProductWithOptionsRow struct {
	ID         uuid.UUID          `json:"id"`
	Name       string             `json:"name"`
	CategoryID *int32             `json:"category_id"`
	ImageUrl   *string            `json:"image_url"`
	Price      int64              `json:"price"`
	Stock      int32              `json:"stock"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	DeletedAt  pgtype.Timestamptz `json:"deleted_at"`
	Options    interface{}        `json:"options"`
}

// Retrieves a single product and aggregates its options into a JSON array.
// This is an efficient way to fetch a product and its variants in one query.
// Now filters out soft-deleted options.
func (q *Queries) GetProductWithOptions(ctx context.Context, id uuid.UUID) (GetProductWithOptionsRow, error) {
	row := q.db.QueryRow(ctx, getProductWithOptions, id)
	var i GetProductWithOptionsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CategoryID,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Options,
	)
	return i, err
}

const listDeletedProducts = `-- name: ListDeletedProducts :many
SELECT
    p.id,
    p.name,
    p.price,
    p.stock,
    p.image_url,
    c.name as category_name,
    c.id as category_id,
    p.deleted_at
FROM
    products p
        LEFT JOIN
    categories c ON p.category_id = c.id
WHERE
    ($3::int IS NULL OR p.category_id = $3)
  AND
    ($4::text IS NULL OR p.name ILIKE '%' || $4 || '%')
  AND p.deleted_at IS NOT NULL
ORDER BY
    p.deleted_at DESC
LIMIT $1 OFFSET $2
`

type ListDeletedProductsParams struct {
	Limit      int32   `json:"limit"`
	Offset     int32   `json:"offset"`
	CategoryID *int32  `json:"category_id"`
	SearchText *string `json:"search_text"`
}

type ListDeletedProductsRow struct {
	ID           uuid.UUID          `json:"id"`
	Name         string             `json:"name"`
	Price        int64              `json:"price"`
	Stock        int32              `json:"stock"`
	ImageUrl     *string            `json:"image_url"`
	CategoryName *string            `json:"category_name"`
	CategoryID   *int32             `json:"category_id"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) ListDeletedProducts(ctx context.Context, arg ListDeletedProductsParams) ([]ListDeletedProductsRow, error) {
	rows, err := q.db.Query(ctx, listDeletedProducts,
		arg.Limit,
		arg.Offset,
		arg.CategoryID,
		arg.SearchText,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDeletedProductsRow{}
	for rows.Next() {
		var i ListDeletedProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Stock,
			&i.ImageUrl,
			&i.CategoryName,
			&i.CategoryID,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionsForProduct = `-- name: ListOptionsForProduct :many
SELECT id, product_id, name, additional_price, image_url, created_at, updated_at, deleted_at FROM product_options
WHERE product_id = $1
ORDER BY name ASC
`

// Retrieves all options for a single product.
func (q *Queries) ListOptionsForProduct(ctx context.Context, productID uuid.UUID) ([]ProductOption, error) {
	rows, err := q.db.Query(ctx, listOptionsForProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductOption{}
	for rows.Next() {
		var i ProductOption
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Name,
			&i.AdditionalPrice,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT
    p.id,
    p.name,
    p.price,
    p.stock,
    p.image_url,
    c.name as category_name,
    c.id as category_id
FROM
    products p
        LEFT JOIN
    categories c ON p.category_id = c.id
WHERE
    ($3::int IS NULL OR p.category_id = $3)
  AND
    ($4::text IS NULL OR p.name ILIKE '%' || $4 || '%')
  AND p.deleted_at IS NULL
ORDER BY
    p.name ASC
LIMIT $1 OFFSET $2
`

type ListProductsParams struct {
	Limit      int32   `json:"limit"`
	Offset     int32   `json:"offset"`
	CategoryID *int32  `json:"category_id"`
	SearchText *string `json:"search_text"`
}

type ListProductsRow struct {
	ID           uuid.UUID `json:"id"`
	Name         string    `json:"name"`
	Price        int64     `json:"price"`
	Stock        int32     `json:"stock"`
	ImageUrl     *string   `json:"image_url"`
	CategoryName *string   `json:"category_name"`
	CategoryID   *int32    `json:"category_id"`
}

// Lists products with filtering and pagination.
// Does not include variants for performance reasons on a list view.
func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]ListProductsRow, error) {
	rows, err := q.db.Query(ctx, listProducts,
		arg.Limit,
		arg.Offset,
		arg.CategoryID,
		arg.SearchText,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProductsRow{}
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Stock,
			&i.ImageUrl,
			&i.CategoryName,
			&i.CategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreProduct = `-- name: RestoreProduct :exec
UPDATE products
SET deleted_at = NULL
WHERE id = $1
`

func (q *Queries) RestoreProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, restoreProduct, id)
	return err
}

const restoreProductsBulk = `-- name: RestoreProductsBulk :exec
UPDATE products
SET deleted_at = NULL
WHERE id = ANY($1::uuid[])
`

func (q *Queries) RestoreProductsBulk(ctx context.Context, dollar_1 []uuid.UUID) error {
	_, err := q.db.Exec(ctx, restoreProductsBulk, dollar_1)
	return err
}

const softDeleteProduct = `-- name: SoftDeleteProduct :exec
UPDATE products
SET deleted_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteProduct, id)
	return err
}

const softDeleteProductOption = `-- name: SoftDeleteProductOption :exec
update product_options
SET deleted_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

// Deletes a single product option.
func (q *Queries) SoftDeleteProductOption(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteProductOption, id)
	return err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET
    name = COALESCE($1, name),
    category_id = COALESCE($2, category_id),
    image_url = COALESCE($3, image_url),
    price = COALESCE($4, price),
    stock = COALESCE($5, stock)
WHERE
    id = $6
RETURNING id, name, category_id, image_url, price, stock, created_at, updated_at, deleted_at
`

type UpdateProductParams struct {
	Name       *string   `json:"name"`
	CategoryID *int32    `json:"category_id"`
	ImageUrl   *string   `json:"image_url"`
	Price      *int64    `json:"price"`
	Stock      *int32    `json:"stock"`
	ID         uuid.UUID `json:"id"`
}

// Updates a product's details. Use COALESCE for optional fields.
func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.Name,
		arg.CategoryID,
		arg.ImageUrl,
		arg.Price,
		arg.Stock,
		arg.ID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CategoryID,
		&i.ImageUrl,
		&i.Price,
		&i.Stock,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateProductOption = `-- name: UpdateProductOption :one
UPDATE product_options
SET
    name = COALESCE($1, name),
    additional_price = COALESCE($2, additional_price),
    image_url = COALESCE($3, image_url)
WHERE
    id = $4
RETURNING id, product_id, name, additional_price, image_url, created_at, updated_at, deleted_at
`

type UpdateProductOptionParams struct {
	Name            *string   `json:"name"`
	AdditionalPrice *int64    `json:"additional_price"`
	ImageUrl        *string   `json:"image_url"`
	ID              uuid.UUID `json:"id"`
}

// Updates a specific product option.
func (q *Queries) UpdateProductOption(ctx context.Context, arg UpdateProductOptionParams) (ProductOption, error) {
	row := q.db.QueryRow(ctx, updateProductOption,
		arg.Name,
		arg.AdditionalPrice,
		arg.ImageUrl,
		arg.ID,
	)
	var i ProductOption
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.AdditionalPrice,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
