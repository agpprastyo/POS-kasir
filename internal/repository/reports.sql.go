// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reports.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getCancellationReasons = `-- name: GetCancellationReasons :many
SELECT
    cr.id AS reason_id,
    cr.reason,
    COUNT(o.id) AS cancelled_orders
FROM orders o
         JOIN cancellation_reasons cr ON o.cancellation_reason_id = cr.id
WHERE o.status = 'cancelled'
  AND o.created_at::date BETWEEN $1 AND $2
GROUP BY cr.id, cr.reason
ORDER BY cancelled_orders DESC
`

type GetCancellationReasonsParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetCancellationReasonsRow struct {
	ReasonID        int32  `json:"reason_id"`
	Reason          string `json:"reason"`
	CancelledOrders int64  `json:"cancelled_orders"`
}

func (q *Queries) GetCancellationReasons(ctx context.Context, arg GetCancellationReasonsParams) ([]GetCancellationReasonsRow, error) {
	rows, err := q.db.Query(ctx, getCancellationReasons, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCancellationReasonsRow{}
	for rows.Next() {
		var i GetCancellationReasonsRow
		if err := rows.Scan(&i.ReasonID, &i.Reason, &i.CancelledOrders); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCashierPerformance = `-- name: GetCashierPerformance :many
SELECT
    u.id AS user_id,
    u.username,
    COUNT(o.id) AS order_count,
    COALESCE(SUM(o.net_total), 0) AS total_sales
FROM orders o
         JOIN users u ON o.user_id = u.id
WHERE o.created_at::date BETWEEN $1 AND $2
  AND o.status IN ('paid', 'served')
GROUP BY u.id, u.username
ORDER BY total_sales DESC
`

type GetCashierPerformanceParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetCashierPerformanceRow struct {
	UserID     uuid.UUID   `json:"user_id"`
	Username   string      `json:"username"`
	OrderCount int64       `json:"order_count"`
	TotalSales interface{} `json:"total_sales"`
}

func (q *Queries) GetCashierPerformance(ctx context.Context, arg GetCashierPerformanceParams) ([]GetCashierPerformanceRow, error) {
	rows, err := q.db.Query(ctx, getCashierPerformance, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCashierPerformanceRow{}
	for rows.Next() {
		var i GetCashierPerformanceRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.OrderCount,
			&i.TotalSales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategorySales = `-- name: GetCategorySales :many
SELECT
    c.id AS category_id,
    c.name AS category_name,
    SUM(oi.quantity) AS total_quantity,
    SUM(oi.net_subtotal) AS total_revenue
FROM order_items oi
         JOIN products p ON oi.product_id = p.id
         JOIN categories c ON p.category_id = c.id
         JOIN orders o ON oi.order_id = o.id
WHERE o.created_at::date BETWEEN $1 AND $2
  AND o.status IN ('paid', 'served')
GROUP BY c.id, c.name
ORDER BY total_revenue DESC
`

type GetCategorySalesParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetCategorySalesRow struct {
	CategoryID    int32  `json:"category_id"`
	CategoryName  string `json:"category_name"`
	TotalQuantity int64  `json:"total_quantity"`
	TotalRevenue  int64  `json:"total_revenue"`
}

func (q *Queries) GetCategorySales(ctx context.Context, arg GetCategorySalesParams) ([]GetCategorySalesRow, error) {
	rows, err := q.db.Query(ctx, getCategorySales, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategorySalesRow{}
	for rows.Next() {
		var i GetCategorySalesRow
		if err := rows.Scan(
			&i.CategoryID,
			&i.CategoryName,
			&i.TotalQuantity,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardSummary = `-- name: GetDashboardSummary :one
SELECT
    COALESCE(SUM(net_total), 0) AS total_sales,
    COUNT(*) AS total_orders,
    COUNT(DISTINCT user_id) AS unique_cashiers,
    (SELECT COUNT(*) FROM products WHERE deleted_at IS NULL) AS total_products
FROM orders
WHERE created_at::date = CURRENT_DATE
  AND status IN ('paid', 'served')
`

type GetDashboardSummaryRow struct {
	TotalSales     interface{} `json:"total_sales"`
	TotalOrders    int64       `json:"total_orders"`
	UniqueCashiers int64       `json:"unique_cashiers"`
	TotalProducts  int64       `json:"total_products"`
}

func (q *Queries) GetDashboardSummary(ctx context.Context) (GetDashboardSummaryRow, error) {
	row := q.db.QueryRow(ctx, getDashboardSummary)
	var i GetDashboardSummaryRow
	err := row.Scan(
		&i.TotalSales,
		&i.TotalOrders,
		&i.UniqueCashiers,
		&i.TotalProducts,
	)
	return i, err
}

const getPaymentMethodSales = `-- name: GetPaymentMethodSales :many
SELECT
    pm.id AS payment_method_id,
    pm.name AS payment_method_name,
    COUNT(o.id) AS order_count,
    COALESCE(SUM(o.net_total), 0) AS total_sales
FROM orders o
         JOIN payment_methods pm ON o.payment_method_id = pm.id
WHERE o.created_at::date BETWEEN $1 AND $2
  AND o.status IN ('paid', 'served')
GROUP BY pm.id, pm.name
ORDER BY total_sales DESC
`

type GetPaymentMethodSalesParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetPaymentMethodSalesRow struct {
	PaymentMethodID   int32       `json:"payment_method_id"`
	PaymentMethodName string      `json:"payment_method_name"`
	OrderCount        int64       `json:"order_count"`
	TotalSales        interface{} `json:"total_sales"`
}

func (q *Queries) GetPaymentMethodSales(ctx context.Context, arg GetPaymentMethodSalesParams) ([]GetPaymentMethodSalesRow, error) {
	rows, err := q.db.Query(ctx, getPaymentMethodSales, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaymentMethodSalesRow{}
	for rows.Next() {
		var i GetPaymentMethodSalesRow
		if err := rows.Scan(
			&i.PaymentMethodID,
			&i.PaymentMethodName,
			&i.OrderCount,
			&i.TotalSales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductSalesPerformance = `-- name: GetProductSalesPerformance :many
SELECT
    p.id AS product_id,
    p.name AS product_name,
    SUM(oi.quantity) AS total_quantity,
    SUM(oi.net_subtotal) AS total_revenue
FROM order_items oi
         JOIN products p ON oi.product_id = p.id
         JOIN orders o ON oi.order_id = o.id
WHERE o.created_at::date BETWEEN $1 AND $2
  AND o.status IN ('paid', 'served')
GROUP BY p.id, p.name
ORDER BY total_quantity DESC
`

type GetProductSalesPerformanceParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetProductSalesPerformanceRow struct {
	ProductID     uuid.UUID `json:"product_id"`
	ProductName   string    `json:"product_name"`
	TotalQuantity int64     `json:"total_quantity"`
	TotalRevenue  int64     `json:"total_revenue"`
}

func (q *Queries) GetProductSalesPerformance(ctx context.Context, arg GetProductSalesPerformanceParams) ([]GetProductSalesPerformanceRow, error) {
	rows, err := q.db.Query(ctx, getProductSalesPerformance, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductSalesPerformanceRow{}
	for rows.Next() {
		var i GetProductSalesPerformanceRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.TotalQuantity,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesSummary = `-- name: GetSalesSummary :many
SELECT
    created_at::date AS date,
    COUNT(*) AS order_count,
    COALESCE(SUM(net_total), 0) AS total_sales
FROM orders
WHERE created_at::date BETWEEN $1 AND $2
  AND status IN ('paid', 'served')
GROUP BY date
ORDER BY date
`

type GetSalesSummaryParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetSalesSummaryRow struct {
	Date       pgtype.Date `json:"date"`
	OrderCount int64       `json:"order_count"`
	TotalSales interface{} `json:"total_sales"`
}

func (q *Queries) GetSalesSummary(ctx context.Context, arg GetSalesSummaryParams) ([]GetSalesSummaryRow, error) {
	rows, err := q.db.Query(ctx, getSalesSummary, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSalesSummaryRow{}
	for rows.Next() {
		var i GetSalesSummaryRow
		if err := rows.Scan(&i.Date, &i.OrderCount, &i.TotalSales); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
