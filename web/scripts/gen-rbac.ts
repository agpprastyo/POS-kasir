import fs from 'fs';
import path from 'path';

const SWAGGER_PATH = path.join(process.cwd(), 'api-docs/swagger.json');
const OUTPUT_PATH = path.join(process.cwd(), 'src/lib/auth/rbacRules.ts');

interface SwaggerOperation {
    tags?: string[];
    summary?: string;
    description?: string;
    operationId?: string;
    'x-roles'?: string[];
    [key: string]: any;
}

interface SwaggerPath {
    [method: string]: SwaggerOperation;
}

interface SwaggerDoc {
    paths: {
        [path: string]: SwaggerPath;
    };
    [key: string]: any;
}

function generateRBAC() {
    console.log(`[RBAC-Gen] Reading swagger from: ${SWAGGER_PATH}`);

    if (!fs.existsSync(SWAGGER_PATH)) {
        console.error(`[RBAC-Gen] Swagger file not found: ${SWAGGER_PATH}`);
        process.exit(1);
    }

    const swaggerContent = fs.readFileSync(SWAGGER_PATH, 'utf-8');
    const swagger: SwaggerDoc = JSON.parse(swaggerContent);

    const rules: Record<string, string[]> = {};
    let count = 0;

    Object.entries(swagger.paths).forEach(([pathName, pathObj]) => {
        Object.entries(pathObj).forEach(([method, operation]) => {
            const roles = operation['x-roles'];
            // Normalize path to generic pattern if possible, though exact match is safer for now.
            // Swagger paths usually look like /api/v1/users/{id}

            // We need a key that the frontend can construct. 
            // The best way is typically "METHOD PATH" e.g "GET /api/v1/users/{id}"

            const key = `${method.toUpperCase()} ${pathName}`;

            if (roles && roles.length > 0) {
                rules[key] = roles;
                count++;
            }
        });
    });

    const fileContent = `// This file is auto-generated by scripts/gen-rbac.ts
// Do not edit manually.

export const RBAC_RULES: Record<string, string[]> = ${JSON.stringify(rules, null, 4)};
`;

    fs.writeFileSync(OUTPUT_PATH, fileContent);
    console.log(`[RBAC-Gen] Generated ${count} RBAC rules in: ${OUTPUT_PATH}`);
}

generateRBAC();
